// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    // NOTE: When using mysql or sqlserver, uncomment the @db.Text annotations in model Account below
    // Further reading:
    // https://next-auth.js.org/adapters/prisma#create-the-prisma-schema
    // https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#string
    url      = env("DATABASE_URL")
}

// Enums used across the schema

enum AddressType {
    Billing
    Shipping
    Mailing
    Other
}

enum RoleName {
    Admin
    Bindery
    Customer
    Finance
    Manager
    Prepress
    Production
    Sales
    User
}

enum OrderStatus {
    Draft
    Proofing
    Approved
    Completed
    Cancelled
}

enum PaymentMethod {
    Cash
    Check
    CreditCard
    DebitCard
    PayPal
    Venmo
    Zelle
}

enum PaymentStatus {
    Paid
    Unpaid
    Partial
    Pending
    Overdue
    Refunded
}

enum PermissionName {
    CreateAddress
    CreateApiKey
    CreateCompany
    CreateInvitation
    CreateOffice
    CreateOrder
    CreateOrderItem
    CreatePasswordReset
    CreateProcessingOptions
    CreateRole
    CreateShippingInfo
    CreateTypesetting
    CreateUser
    CreateWorkOrder
    DeleteAddress
    DeleteApiKey
    DeleteCompany
    DeleteInvitation
    DeleteOffice
    DeleteOrder
    DeleteOrderItem
    DeletePasswordReset
    DeleteProcessingOptions
    DeleteRole
    DeleteShippingInfo
    DeleteTypesetting
    DeleteUser
    DeleteWorkOrder
    UpdateAddress
    UpdateApiKey
    UpdateCompany
    UpdateInvitation
    UpdateOffice
    UpdateOrder
    UpdateOrderItem
    UpdatePasswordReset
    UpdateProcessingOptions
    UpdateRole
    UpdateShippingInfo
    UpdateTypesetting
    UpdateUser
    UpdateWorkOrder
}

enum ProofType {
    Digital
    HardCopy
    PDF
    Other
}

enum ShippingMethod {
    Courier
    Deliver
    DHL
    FedEx
    Other
    UPS
    USPS
}

enum ShippingType {
    Residential
    Commercial
    Other
}

enum StaticRoles {
    ADMIN
    BINDERY
    CUSTOMER
    FINANCE
    MANAGER
    PREPRESS
    PRODUCTION
    SALES
    USER
}

enum StockStatus {
    InStock
    OnHand
    CS
    Ordered
    OutOfStock
    LowStock
}

// End Enums

model Post {
    id        Int      @id @default(autoincrement())
    name      String
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    createdBy   User   @relation(fields: [createdById], references: [id])
    createdById String

    @@index([name])
}

// Necessary for Next auth
model Account {
    id                String  @id @default(cuid())
    userId            String
    type              String
    provider          String
    providerAccountId String
    refresh_token     String? // @db.Text
    access_token      String? // @db.Text
    expires_at        Int?
    token_type        String?
    scope             String?
    id_token          String? // @db.Text
    session_state     String?
    user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([provider, providerAccountId])
}

// Belongs to Office. An office can have more than one Address.
// The addressType is used to determine if it is a billing, shipping, mailing, or other type of address.
model Address {
    id              String      @id @default(uuid())
    officeId        String
    line1           String
    line2           String?
    city            String
    state           String
    zipCode         String
    country         String
    telephoneNumber String      @default("")
    addressType     AddressType @default(Other)
    Office          Office      @relation(fields: [officeId], references: [id])
}

// Has many Offices.
// Has many Orders.
// Has many WorkOrders.
// Indirectly related to many Users through Office.
model Company {
    id      String   @id @default(uuid())
    name    String
    offices Office[]
}

// Belongs to Company.
// Has many Users.
// Has many Addresses, a minimum of one.
// Has many ShippingInfos.
// Has many WorkOrders.
model Office {
    id           String         @id @default(uuid())
    companyId    String
    users        User[]
    company      Company        @relation(fields: [companyId], references: [id])
    shippingInfo ShippingInfo[]
    Address      Address[]
    workOrder    WorkOrder[]
    Order        Order[]
}

// This takes information from the WorkOrder once it is approved and creates an Order.
// It belongs to a Office and through that a Company.
// It has many ProcessingOptions which are optional.
// It has many OrderItems which at least one is required.
model Order {
    id                  String      @id @default(uuid())
    workOrderId         String      @unique
    officeId            String
    status              OrderStatus // Draft, Proofing, Approved, Completed, etc.
    pressRun            String
    specialInstructions String?
    artwork             String?
    proofType           String?
    proofCount          Int         @default(0)
    approved            Boolean     @default(false)
    prepTime            Int?
    plateRan            String?
    expectedDate        DateTime?
    deposit             Decimal?    @db.Decimal(10, 2)
    costPerM            Decimal?    @db.Decimal(10, 2)
    totalCost           Decimal?    @db.Decimal(10, 2)
    binderyTime         String?
    overUnder           String?
    version             Int         @default(1)

    createdAt         DateTime            @default(now())
    updatedAt         DateTime            @default(now())
    items             OrderItem[]
    shippingInfo      ShippingInfo?       @relation(name: "OrderShipping")
    workOrder         WorkOrder           @relation(fields: [workOrderId], references: [id])
    Typesetting       Typesetting[]
    ProcessingOptions ProcessingOptions[]
    shippingInfoId    String?
    // belongs to Office
    office            Office              @relation(fields: [officeId], references: [id])
}

// This aligns with the WorkOrderItem and is used to create an OrderItem
model OrderItem {
    id           String   @id @default(uuid())
    orderId      String
    description  String
    finishedQty  Int
    pressRun     String
    cs           String
    size         String?
    stockOnHand  Boolean  @default(false)
    stockOrdered String?
    inkColor     String?
    amount       Decimal? @db.Decimal(10, 2)
    order        Order    @relation(fields: [orderId], references: [id])
}

// Permission is used to define the roles and what they can do.
model Permission {
    id          String  @id @default(uuid())
    name        String  @unique
    description String?
    roles       Role[] // Many-to-many relation to Role
}

// This is used to store the information for the WorkOrderItem.
// These options detail the post-printing processing steps and vary by order.
// It belongs to the WorkOrder and is used to store the information for the items in the order.
// It also belongs to the Order if it has been approved.
model ProcessingOptions {
    id             String  @id @default(uuid())
    workOrderId    String  @unique // Ensures one-to-one relationship
    orderId        String? @unique
    cutting        Boolean @default(false)
    padding        Boolean @default(false)
    drilling       Boolean @default(false)
    folding        Boolean @default(false)
    other          String? // Additional notes or custom processing options
    numberingStart Int?
    numberingEnd   Int?
    numberingColor String?

    workOrder WorkOrder @relation(fields: [workOrderId], references: [id])
    Order     Order?    @relation(fields: [orderId], references: [id])
}

// Roles are assigned to a user and define what they can do.
// They are used to define the permissions for a user.
// A user can have many roles.
// A role can have many permissions.
model Role {
    id          String       @id @default(uuid())
    name        RoleName     @unique
    description String?
    users       User[] // Many-to-many relation to User
    permissions Permission[] // Many-to-many relation to Permission
}

model Session {
    id           String   @id @default(cuid())
    sessionToken String   @unique
    userId       String
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// This belongs to the WorkOrder and also the Order if it has been approved.
// It belongs to the Office and is used to store the shipping information for the order.
// It captures both the anticipated and actual shipping details (e.g. shipping date, shipping method, shipping cost, etc.)
model ShippingInfo {
    id                 String         @id @default(uuid())
    workOrderId        String         @unique // Ensures one-to-one relationship
    orderId            String?        @unique // Ensures one-to-one relationship
    instructions       String?
    shippingOther      String? // Additional notes or custom shipping options
    shippingDate       DateTime?
    shippingMethod     ShippingMethod
    shippingCost       Decimal?       @db.Decimal(10, 2)
    officeId           String // Reference to the office location for shipping address
    shipToSameAsBillTo Boolean        @default(false)
    attentionTo        String?

    office    Office    @relation(fields: [officeId], references: [id])
    workOrder WorkOrder @relation(fields: [workOrderId], references: [id])
    order     Order?    @relation(name: "OrderShipping", fields: [orderId], references: [id])
}

// It belongs to the WorkOrder and is used to store the options selected for the proofing process.
// Typesetting captures the details of the typesetting process including proofs and selected options.
// It has many proofs. The first proof is the original and the rest are revisions.
// The last proof is the final proof.
// It has many TypesettingOptions.
// It also has a reference to the Order if it has been approved.

model Typesetting {
    id          String   @id @default(uuid())
    workOrderId String
    orderId     String?
    dateIn      DateTime
    timeIn      String
    cost        Decimal? @db.Decimal(10, 2)
    approved    Boolean  @default(false)
    prepTime    Int?
    plateRan    String?

    proofs            TypesettingProof[]
    workOrder         WorkOrder           @relation(fields: [workOrderId], references: [id])
    TypesettingOption TypesettingOption[]
    Order             Order?              @relation(fields: [orderId], references: [id])
}

// It belongs to Typesetting and is used to store the options selected for typesetting
model TypesettingOption {
    id            String      @id @default(uuid())
    typesettingId String
    option        String // 'Negs', 'Xante', '7200', '9200'
    selected      Boolean     @default(false)
    typesetting   Typesetting @relation(fields: [typesettingId], references: [id])

    @@unique([typesettingId, option])
}

// It belongs to Typesetting and is used to store the proofs submitted for review
model TypesettingProof {
    id            String      @id @default(uuid())
    typesettingId String
    proofNumber   Int // To store the proof number (1 through 5)
    dateSubmitted DateTime? // The date the proof was submitted for review
    notes         String? // Notes or feedback on the proof
    approved      Boolean? // Whether the proof was approved
    typesetting   Typesetting @relation(fields: [typesettingId], references: [id])
}

// This is used to store the information of the User.
// It has a many-to-many relationship with Role through UserRole.
// Office is optional, but if it is present, it is required.
model User {
    id            String          @id @default(cuid())
    name          String?
    email         String?         @unique
    emailVerified DateTime?
    image         String?
    createdAt     DateTime        @default(now())
    updatedAt     DateTime        @default(now())
    accounts      Account[]
    sessions      Session[]
    posts         Post[]
    roles         Role[] // Many-to-many relation to Role
    Office        Office?         @relation(fields: [officeId], references: [id])
    officeId      String?
    workOrders    WorkOrder[]
    WorkOrderNote WorkOrderNote[]
}

model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
}

// This is the main model for the work order. It is used to create an order once approved.
// WorkerOrders are created by the CSR and are used to track the progress of the order.
// WorkOrders serve as the initial step in the order process. Orders are created from WorkOrders.
// It belongs to an Office and through that a Company.
// It has many workOrderItems. It has many workOrderNotes.
// It has one shippingInfo. It has one processingOptions.
// It can have many versions, but only one can be active at a time.
// It has many ProcessingOptions which are optional.
// It has many Typesetting which are optional.
model WorkOrder {
    id       String @id @default(uuid())
    officeId String

    dateIn              DateTime
    inHandsDate         DateTime
    estimateNumber      String
    purchaseOrderNumber String

    pressRun            String
    specialInstructions String?
    artwork             String?
    approved            Boolean @default(false)
    prepTime            Int?
    plateRan            String?

    expectedDate DateTime?
    deposit      Decimal?    @db.Decimal(10, 2)
    costPerM     Decimal?    @db.Decimal(10, 2)
    totalCost    Decimal?    @db.Decimal(10, 2)
    binderyTime  String?
    overUnder    String?
    userId       String
    version      Int         @default(1)
    status       OrderStatus // Draft, Proofing, Approved, Completed, etc.
    createdAt    DateTime    @default(now())
    updatedAt    DateTime    @updatedAt

    office Office @relation(fields: [officeId], references: [id])

    user User @relation(fields: [userId], references: [id])

    shippingInfo ShippingInfo?

    workOrderItems    WorkOrderItem[]
    WorkOrderStock    WorkOrderStock[]
    WorkOrderVersions WorkOrderVersion[]
    Typesetting       Typesetting[]
    ProcessingOptions ProcessingOptions?
    Order             Order?
    WorkOrderNote     WorkOrderNote[]
}

// It belongs to the WorkOrder and is used to store the items for the order.
model WorkOrderItem {
    id           String   @id @default(uuid())
    workOrderId  String
    cutting      String?
    description  String?
    drilling     String?
    finishedQty  Int?
    folding      String?
    other        String?
    pressRun     String?
    cs           String?
    size         String?
    stockOnHand  Boolean  @default(false)
    stockOrdered String?
    inkColor     String?
    amount       Decimal? @db.Decimal(10, 2)

    workOrder WorkOrder @relation(fields: [workOrderId], references: [id])
}

// It belongs to the WorkOrder and is used to store the notes for the order.
model WorkOrderNote {
    id          String   @id @default(uuid())
    workOrderId String
    note        String
    user        User     @relation(fields: [userId], references: [id])
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    workOrder WorkOrder @relation(fields: [workOrderId], references: [id])
    userId    String
}

// It belongs to the WorkOrder and is used to store the stock for the order.
model WorkOrderStock {
    id           String      @id @default(uuid())
    workOrderId  String
    stockQty     Int
    costPerM     Decimal?    @db.Decimal(10, 2)
    totalCost    Decimal?    @db.Decimal(10, 2)
    from         String?
    expectedDate DateTime?
    orderedDate  DateTime?
    received     Boolean     @default(false)
    receivedDate DateTime?
    notes        String?
    stockStatus  StockStatus
    createdAt    DateTime    @default(now())
    updatedAt    DateTime    @updatedAt

    workOrder WorkOrder @relation(fields: [workOrderId], references: [id])
}

// It belongs to the WorkOrder and is used to store the versions for the order.
model WorkOrderVersion {
    id          String   @id @default(uuid())
    workOrderId String
    version     Int
    createdBy   String
    createdAt   DateTime @default(now())

    workOrder WorkOrder @relation(fields: [workOrderId], references: [id])
}
